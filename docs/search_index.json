[
["index.html", "R Textbook 1 Preface", " R Textbook Ian Cero’s CSP 518 Class Spring 2019 1 Preface What follows is an “organic” textbook. It is the product of class discussions and exercises, each of which was recorded as it was presented in class. "],
["basic-r.html", "2 Basic R 2.1 Writing in R and Rmarkdown 2.2 Variables 2.3 Vectors 2.4 Lists 2.5 Dataframes 2.6 Packages", " 2 Basic R 2.1 Writing in R and Rmarkdown 2.1.1 Chatting with R Using R is just a chat with the computer. “Hey, R. What is \\(1 + 2\\)?” 1 + 2 ## [1] 3 2.1.2 Rmarkdown tricks To make text bold, we add two **s around it. To make text italicized, we add just one * around it. If we need special characters (like * or $), then we just add a forward “\\” in front of them (but not behind). Math symbols in your text are process with Latex, just put an “$” before and after your math. Like this, $y = x$ becomes \\(y = x\\). Code blocks To make a code block, press CTRL+ALT+I. Remember you can change the output of a code block by modifying some of its options, like below. banana &lt;- 5 banana + 1 ## [1] 6 2.2 Variables 2.2.1 The assignment operator We make variables with the &lt;- operator. my_special_var &lt;- 1 + 2 my_special_var ## [1] 3 You can TECHNICALLY use = for assignment too. Never do this. my_other_var = 12 my_other_var + my_special_var ## [1] 15 2.2.2 Numerics Doubles Doubles are decimal numbers, like \\(1.1, 2.2, 3.0\\). If I make a number variable without doing anything special, R defaults to a double. a &lt;- 1.1 b &lt;- 2.0 is.double(a) ## [1] TRUE is.double(b) ## [1] TRUE Integers Integers must have an L after them. That is how R knows that you don’t want a double, but instead want a “long-capable integer”. c &lt;- 1L d &lt;- 1 is.integer(c) ## [1] TRUE is.integer(d) ## [1] FALSE Here is a useful cheatsheet for the different numeric operators and how they behave. Operator Expression Result + 10 + 3 13 - 10 - 3 7 * 10 * 3 30 / 10 / 3 3.333 ^ 10 ^ 3 1000 %/% 10 %/% 3 3 %% 10 %% 3 1 Why care about the difference? Almost 99% of the time, this wont matter. But, with big data, integers take up must less memory. object.size(1L:1e6) ## 4000040 bytes XXXX &lt;- Ian, figure out why this isnt work. pryr::object_size(1L:1e6L) ## 4 MB pryr::object_size(seq(1.0, 1e6)) ## 4 MB 2.2.3 Characters Characters are text symbols and they are made with either &quot;&quot; or '', either works. a &lt;- &#39;here is someone\\&#39;s text&#39; b &lt;- &quot;here is more text&quot; a ## [1] &quot;here is someone&#39;s text&quot; b ## [1] &quot;here is more text&quot; To combine two strings, I use paste(). paste(a, b) ## [1] &quot;here is someone&#39;s text here is more text&quot; If I dont want a space, then I used paste0(). paste0(a, b) ## [1] &quot;here is someone&#39;s texthere is more text&quot; 2.2.4 Booleans These are True and False values. You make them with the symbols T or TRUE and F or FALSE. x &lt;- T y &lt;- F To compare them, we can use three operators. &amp; is “and” | is “or” ! is “not” (just give me the opposite of whatever is after me) x &amp; y # false ## [1] FALSE x | y # true ## [1] TRUE x &amp; !y # true ## [1] TRUE We can also have nested equations z &lt;- F x &amp; !(y | z) # true ## [1] TRUE We can also compare numbers. a &lt;- 1 b &lt;- 2 a &lt; 1 ## [1] FALSE a &lt;= 1 ## [1] TRUE a == 1 ## [1] TRUE If I want to compare multiple numbers, I need to do it seperately. (a &gt; 1) | (b &gt; 1) ## [1] TRUE Remember that booleans are ultimately numeric values underneath. d &lt;- T k &lt;- F u &lt;- 5 d*u ## [1] 5 d*k ## [1] 0 as.numeric(d) ## [1] 1 as.numeric(k) ## [1] 0 2.2.5 Special types NA - missing is.na(NA) ## [1] TRUE NaN - you did math wrong 0/0 ## [1] NaN Inf - infinity -5/0 ## [1] -Inf 2.3 Vectors R is built is on vectors. Vectors are collections of a bunch of values of the same type. my_vec &lt;- c(1, 5, 3, 7) my_vec ## [1] 1 5 3 7 If I try to put different types together, they go to the most primitive type (usually a character string). my_other_vec &lt;- c(22, &#39;orange&#39;, T) my_other_vec ## [1] &quot;22&quot; &quot;orange&quot; &quot;TRUE&quot; my_third_vec &lt;- c(T, F, 35) my_third_vec ## [1] 1 0 35 We can also missing values. my_fourth_vec &lt;- c(1, 4, 5, NA) my_fourth_vec ## [1] 1 4 5 NA is.na(my_fourth_vec) ## [1] FALSE FALSE FALSE TRUE If I want to combine two vectors… a &lt;- c(1, 2, 3) b &lt;- c(3, 5, 7) c(a, b) ## [1] 1 2 3 3 5 7 A brief example of matrices matrix( data = c(a, b), nrow = 2, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 3 5 7 Sometimes I want special vectors, direct sequences of numbers. There are two ways to do this. If all I want is a integer sequence (made of doubles), then I use the “&lt;first number&gt;:&lt;last number&gt;”. 1:5 ## [1] 1 2 3 4 5 5:1 ## [1] 5 4 3 2 1 Other times, I need to count by something other than one, so I use seq(from = &lt;start&gt;, to = &lt;end&gt;, by = &lt;number to count by&gt;) seq(from = 1, to = 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 Hint: for brevity, I can leave off function parameter names, as long as I enter them in order seq(1, 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 If I add a constant to a vector, then they all go up by that constant. 1:5 / 3 ## [1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667 I can do math with equal-length sequences too. 1:5 - seq(1, 4, by = .7) ## [1] 0.0 0.3 0.6 0.9 1.2 But they must be equal lengths. 1:5 / 1:4 ## Warning in 1:5/1:4: longer object length is not a multiple of shorter ## object length ## [1] 1 1 1 1 5 To access the elements of a vector, I put a number OR booleans in brackets []. my_vec &lt;- c(&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;pair&#39;) my_vec[2] ## [1] &quot;orange&quot; my_vec[2:4] ## [1] &quot;orange&quot; &quot;banana&quot; &quot;pair&quot; my_vec[c(3, 2, 1, 4)] ## [1] &quot;banana&quot; &quot;orange&quot; &quot;apple&quot; &quot;pair&quot; I can also use bools. my_other_vec &lt;- c(1, 4, 6, 7, 9, 3, 9) my_other_vec &lt; 5 ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE my_other_vec[my_other_vec &lt; 5] ## [1] 1 4 3 I can also use functions that return values to access vectors, if I am creative… my_other_vec[max(my_other_vec) == my_other_vec] ## [1] 9 9 R also has special vectors that are pre-loaded. The most commonly used are letters and LETTERS, which return the lower-case letters and uppercase letters of the English alphabet, respectively. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; 2.4 Lists 2.5 Dataframes Construction Accessing elements inside the dataframe - $ - Rows with numbers - Rows with boolean tests - Columns with numbers - Columns with names - Making new columns Basic data modification 2.5.1 Basic functions What are functions? Common functions rnorm() mean() sd() What about missing data? How can I make my own? 2.6 Packages Base R and the need for packages Package installation Package loading Calling functions without loading a package "],
["visualization.html", "3 Visualization 3.1 Base R 3.2 ggplot", " 3 Visualization There are many ways to visualize data in R. Two of the most common include Base R’s built-in functions and the ggplot2 package. 3.1 Base R hist() barplot() plot() 3.2 ggplot 3.2.1 The Grammar of Graphics All statistical graphics share the same deep structure, a “Grammar of Graphics”. This means that any given plot can be uniquely identified (reproduced), given the following inputs. A dataset A coordinate system (2d plane, 3d sphere, etc) A facet specification (panel arrangement) Mappings from variables to aesthetic features One scale for each aesthetic mapping One or more layers of geometic objects (“geoms”), statistical functions, and position adjustments 3.2.2 ggplot2 The most popular graphics package in R to date (maybe even accross all programming languages) is ggplot2. An update of the original ggplot package, ggplot2 is based on the Grammar of Graphics above. It functions are designed specifically to behave like a grammar, in which you add plot elements together like a sentence. Lets explore how to build a plot. Blank plot Points Smoothed line Themes Labels Saving your plot File type Quality Dimensions Facets Where to learn more? The ggplot cheatsheet is available here as is the quickest way to look up something you might have briefly forgotten. For more complex questions, https://ggplot2.tidyverse.org/index.html contains numerous worked examples that will bring your plots from plain old publishable to down right beautiful. If you have a really specific question, the “ggplot” tag on Stack Overflow is your best friend. Ask and you shall receive (help)! "]
]
