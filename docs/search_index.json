[
["index.html", "R Textbook 1 Preface", " R Textbook Ian Cero’s CSP 518 Class Spring 2019 1 Preface What follows is an “organic” textbook. It is the product of class discussions and exercises, each of which was recorded as it was presented in class. "],
["basic-r.html", "2 Basic R 2.1 Writing in R and Rmarkdown 2.2 Variables 2.3 Vectors 2.4 Lists 2.5 Dataframes 2.6 Functions 2.7 Packages", " 2 Basic R 2.1 Writing in R and Rmarkdown 2.1.1 Chatting with R Using R is just a chat with the computer. “Hey, R. What is \\(1 + 2\\)?” 1 + 2 ## [1] 3 2.1.2 Rmarkdown tricks To make text bold, we add two **s around it. To make text italicized, we add just one * around it. If we need special characters (like * or $), then we just add a forward “\\” in front of them (but not behind). Math symbols in your text are process with Latex, just put an “$” before and after your math. Like this, $y = x$ becomes \\(y = x\\). 2.1.3 Code blocks To make a code block, press CTRL+ALT+I. banana &lt;- 5 banana + 1 ## [1] 6 2.2 Variables Variables are values that I want to give names to and save for later. 2.2.1 The assignment operator We make variables with the &lt;- operator. This is called the assignment operator because it assigns values on the right to names on the left. If I want to know what the value of a variable is, I can run it alone on its own line. my_special_var &lt;- 1 + 2 my_special_var ## [1] 3 You can TECHNICALLY use = for assignment too. Never do this. my_other_var = 12 my_other_var + my_special_var ## [1] 15 The = symbol gets also used for a few other things in R. So, using it to assign variables will make your code more confusing to you, when you go back to read it over later. 2.2.2 Numerics Doubles Doubles are decimal numbers, like \\(1.1, 2.2, 3.0\\). If I make a number variable without doing anything special, R defaults to a double. a &lt;- 1.1 b &lt;- 2.0 is.double(a) ## [1] TRUE is.double(b) ## [1] TRUE Integers Integers must have an L after them. That is how R knows that you don’t want a double, but instead want a “long-capable integer”. c &lt;- 1L d &lt;- 1 is.integer(c) ## [1] TRUE is.integer(d) ## [1] FALSE Here is a useful cheatsheet for the different numeric operators and how they behave. Operator Expression Result + 10 + 3 13 - 10 - 3 7 * 10 * 3 30 / 10 / 3 3.333 ^ 10 ^ 3 1000 %/% 10 %/% 3 3 %% 10 %% 3 1 Why care about the difference? Almost 99% of the time, this wont matter. But, with big data, integers take up must less memory. my_integers &lt;- seq(from = 1L, to = 1e6L, by = 1L) my_doubles &lt;- seq(from = 1.0, to = 1e6, by = 1.0) object.size(my_integers) ## 4000048 bytes object.size(my_doubles) ## 8000048 bytes Note here that although we are using only whole numbers from 1 to 1 million, the first sequence (my_integers) is stored as an integer and the second sequence (my_doubles) is stored as a number that may include decimals. This second case needs more space (twice as much) to be allocated in advance, even if we never use those decimal places. Again, this will almost never matter for most people, most of the time. However, it is good to be aware of for when your datasets get large (i.e., several million cases or more). 2.2.3 Characters Characters are text symbols and they are made with either &quot;&quot; or '', either works. a &lt;- &#39;here is someone\\&#39;s text&#39; b &lt;- &quot;here is more text&quot; a ## [1] &quot;here is someone&#39;s text&quot; b ## [1] &quot;here is more text&quot; To combine two strings, I use paste(). paste(a, b) ## [1] &quot;here is someone&#39;s text here is more text&quot; If I dont want a space, then I used paste0(). paste0(a, b) ## [1] &quot;here is someone&#39;s texthere is more text&quot; 2.2.4 Booleans These are True and False values. You make them with the symbols T or TRUE and F or FALSE. x &lt;- T y &lt;- F To compare them, we can use three operators. &amp; is “and” | is “or” ! is “not” (just give me the opposite of whatever is after me) x &amp; y # false ## [1] FALSE x | y # true ## [1] TRUE x &amp; !y # true ## [1] TRUE We can also have nested equations z &lt;- F x &amp; !(y | z) # true ## [1] TRUE We can also compare numbers. a &lt;- 1 b &lt;- 2 a &lt; 1 ## [1] FALSE a &lt;= 1 ## [1] TRUE a == 1 ## [1] TRUE If I want to compare multiple numbers, I need to do it seperately. (a &gt; 1) | (b &gt; 1) ## [1] TRUE Remember that booleans are ultimately numeric values underneath. d &lt;- T k &lt;- F u &lt;- 5 d*u ## [1] 5 d*k ## [1] 0 as.numeric(d) ## [1] 1 as.numeric(k) ## [1] 0 2.2.5 Special types NA - missing is.na(NA) ## [1] TRUE NaN - you did math wrong 0/0 ## [1] NaN Inf - infinity -5/0 ## [1] -Inf 2.3 Vectors R is built is on vectors. Vectors are collections of a bunch of values of the same type. my_vec &lt;- c(1, 5, 3, 7) my_vec ## [1] 1 5 3 7 If I try to put different types together, they go to the most primitive type (usually a character string). my_other_vec &lt;- c(22, &#39;orange&#39;, T) my_other_vec ## [1] &quot;22&quot; &quot;orange&quot; &quot;TRUE&quot; my_third_vec &lt;- c(T, F, 35) my_third_vec ## [1] 1 0 35 We can also missing values. my_fourth_vec &lt;- c(1, 4, 5, NA) my_fourth_vec ## [1] 1 4 5 NA is.na(my_fourth_vec) ## [1] FALSE FALSE FALSE TRUE If I want to combine two vectors… a &lt;- c(1, 2, 3) b &lt;- c(3, 5, 7) c(a, b) ## [1] 1 2 3 3 5 7 A brief example of matrices matrix( data = c(a, b), nrow = 2, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 3 5 7 Sometimes I want special vectors, direct sequences of numbers. There are two ways to do this. If all I want is a integer sequence (made of doubles), then I use the “&lt;first number&gt;:&lt;last number&gt;”. 1:5 ## [1] 1 2 3 4 5 5:1 ## [1] 5 4 3 2 1 Other times, I need to count by something other than one, so I use seq(from = &lt;start&gt;, to = &lt;end&gt;, by = &lt;number to count by&gt;) seq(from = 1, to = 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 Hint: for brevity, I can leave off function parameter names, as long as I enter them in order seq(1, 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 If I add a constant to a vector, then they all go up by that constant. 1:5 / 3 ## [1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667 I can do math with equal-length sequences too. 1:5 - seq(1, 4, by = .7) ## [1] 0.0 0.3 0.6 0.9 1.2 But they must be equal lengths. 1:5 / 1:4 ## Warning in 1:5/1:4: longer object length is not a multiple of shorter ## object length ## [1] 1 1 1 1 5 To access the elements of a vector, I put a number OR booleans in brackets []. my_vec &lt;- c(&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;pair&#39;) my_vec[2] ## [1] &quot;orange&quot; my_vec[2:4] ## [1] &quot;orange&quot; &quot;banana&quot; &quot;pair&quot; my_vec[c(3, 2, 1, 4)] ## [1] &quot;banana&quot; &quot;orange&quot; &quot;apple&quot; &quot;pair&quot; I can also use bools. my_other_vec &lt;- c(1, 4, 6, 7, 9, 3, 9) my_other_vec &lt; 5 ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE my_other_vec[my_other_vec &lt; 5] ## [1] 1 4 3 I can also use functions that return values to access vectors, if I am creative… my_other_vec[max(my_other_vec) == my_other_vec] ## [1] 9 9 R also has special vectors that are pre-loaded. The most commonly used are letters and LETTERS, which return the lower-case letters and uppercase letters of the English alphabet, respectively. vec &lt;- c(1, 3, 4, 5, 3, 2, NA) mean(vec, na.rm = T) ## [1] 3 2.4 Lists &lt;&lt; More on lists to come &gt;&gt; Lists are special vectors that can hold multiple types of elements, even vectors my_vec &lt;- c(4, 5, 6) my_list &lt;- list(1, &#39;banana&#39;, 3, NA, my_vec) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] NA ## ## [[5]] ## [1] 4 5 6 2.5 Dataframes 2.5.1 Construction Dataframes are spreadsheets. Under the hood of R, they are just lists of vectors, where all the vectors are required to be the same length. To make one, you can call the data.frame() function and put your vectors inside. heights &lt;- c(60, 65, 71, 72, 64) sexes &lt;- c(&#39;female&#39;, &#39;female&#39;, &#39;male&#39;, &#39;male&#39;, &#39;female&#39;) shoes &lt;- c(&#39;Adidas&#39;, &#39;Nike&#39;, &#39;Nike&#39;, &#39;Salvatore Ferragamo&#39;, &#39;Reebok&#39;) df &lt;- data.frame(height = heights, sex = sexes, shoes = shoes) df ## height sex shoes ## 1 60 female Adidas ## 2 65 female Nike ## 3 71 male Nike ## 4 72 male Salvatore Ferragamo ## 5 64 female Reebok 2.5.2 Built-in dataframes R has numerous built-in datasets that are ideal for demonstration purposes. We can get access to them using the data() command. This will load the data into our session, so we can then look at it. data(&#39;mtcars&#39;) mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Some datasets do not come in the form of a dataframe right away, but they can be converted into one using the as.data.frame() function. data(Seatbelts) is.data.frame(Seatbelts) ## [1] FALSE seatbelts_df &lt;- as.data.frame(Seatbelts) is.data.frame(seatbelts_df) ## [1] TRUE 2.6 Functions A function is a piece of code that does work for you. It takes inputs and (usually) returns outputs. For example, the sum() function takes the sum of a numeric vector. my_vec &lt;- c(3, 6, 2, 3) sum(my_vec) ## [1] 14 2.6.1 Getting help If I ever need to know something about a function, I can put a question mark in front of it (no ()s) and run that line. That will bring up the help document for that function. ?sum 2.6.2 Function parameters In addition to the data they take as input, most functions have additional parameters (sometimes called “arguments”, but they mean the same thing). Looking at its help file, the sum() function has two parameters: ..., the numbers you want to sum na.rm = FALSE, which tells sum() whether you want to remove (‘rm’) missing values (‘na’) before summing. Let’s look at what happens when we try to sum() a vector with a missing value. my_vec &lt;- c(5, NA, 2, 3) # should be 10 sum(my_vec) ## [1] NA R tells us the answer is missing (NA) because at least one of the vector elements is missing. This is to be conservative and to force you never to ignore missing values by accident. But what do we do if we really do want to sum all available values, ignoring the missing values. Again, looking at the help file, we can see that the na.rm parameter of the function is followed by = FALSE, under the Usage heading of that help document (look for sum(..., na.rm = FALSE)). This tells us that the parameter na.rm, which tells sum() whether to remove missing values from the calulation, defaults to FALSE. To get sum() to ignore the missing values in our vector, we simply set na.rm to TRUE (or T for short). sum(my_vec, na.rm = T) # should be 10 ## [1] 10 2.7 Packages Packages are collections of functions that someone else put together for you. You can install them using the install.packages() function, with the name of your package inside the () - don’t forget to use either single (' ') or double quotes (&quot; &quot;) around the package name too. install.packages(&#39;ggplot2&#39;) Once installed, use the library() function to load your package into your R session. Note, you don’t need quotes here. library(ggplot2) "],
["visualization.html", "3 Visualization 3.1 Base R 3.2 ggplot", " 3 Visualization There are many ways to visualize data in R. Two of the most common include Base R’s built-in functions and the ggplot2 package. 3.1 Base R The term “Base R” refers to the set of packages and functions that R loads into each session by default. These packages include several statistical and plotting functions you will probably use a lot. Some of the most common plotting functions are given below. hist() rpois(100, lambda = 3) ## [1] 3 2 5 4 2 4 0 1 0 4 1 7 4 2 1 7 0 3 2 2 1 3 5 2 5 4 1 4 1 3 3 3 5 1 3 ## [36] 7 4 6 4 4 5 0 4 3 1 2 3 1 4 2 2 3 4 1 1 3 3 1 4 3 1 4 5 0 2 2 1 1 3 4 ## [71] 1 6 2 5 3 3 2 0 2 3 2 4 3 3 5 8 3 3 3 3 3 3 2 4 5 1 2 4 4 1 my_vals &lt;- rexp(100, 10) hist( my_vals, breaks = 20, main = &#39;Plot of Exponential Dis.&#39;, xlab = &#39;X Values&#39;, ylab = &#39;Y values&#39;, col = &#39;cyan&#39;) barplot() heights &lt;- 1:10 barplot(heights) plot() x_vals &lt;- 1:10 y_values &lt;- rnorm(10) plot(x_vals, y_values, main = &#39;Banana&#39;, xlab = &#39;My X&#39;) 3.2 ggplot All statistical graphics share the same deep structure, a “Grammar of Graphics”. This means that any given plot can be uniquely identified (reproduced), given the following inputs. A dataset A coordinate system (2d Cartesian plane, 3d spherical coordinates, even quaternions!1) A facet specification (panel arrangement) Mappings from variables to aesthetic features One scale for each aesthetic mapping One or more layers of geometic objects (“geoms”), statistical functions, and position adjustments The most popular graphics package in R to date (maybe even accross all programming languages) is ggplot2. An update of the original ggplot package, ggplot2 is based on the Grammar of Graphics above. It functions are designed specifically to behave like a grammar, in which you add plot elements together like a sentence. Lets explore how to build a plot. We’ll start by loading the ggplot2 package and one of its built-in datasets (called mpg). This dataset includes information on 234 cars that will be convenient for us to plot. install.packages(&#39;ggplot2&#39;) library(ggplot2) data(mpg) mpg ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows 3.2.1 Blank ggplot plot ggplot(mpg) 3.2.2 Geoms Getting points to display (displ, hwy) ggplot(mpg) + geom_point(mapping = aes(x = displ, y = cty)) ggplot(mpg, mapping = aes(x = displ)) + geom_point(mapping = aes(y = cty), color = &#39;steelblue&#39;) + geom_point(mapping = aes(y = hwy), color = &#39;tomato&#39;) Other features of points we can change (size = cyl, color = class) ggplot(mpg, mapping = aes(x = displ, shape = drv, color = drv)) + geom_point(mapping = aes(y = cty)) + geom_point(mapping = aes(y = hwy)) Smoothed line —— (2nd block) Lines data(beavers) ggplot(beaver1, mapping = aes(x = time, y = temp)) + geom_point() + geom_line() Vlines and Hlines Density plots Histograms Boxplots 3.2.3 Stat Functions 3.2.4 Themes 3.2.5 Labels 3.2.6 Scales 3.2.7 Saving your plot** File type Quality Dimensions 3.2.8 Facets &lt;&gt; 3.2.9 Where to learn more The ggplot cheatsheet is available here as is the quickest way to look up something you might have briefly forgotten. For more complex questions, https://ggplot2.tidyverse.org/index.html contains numerous worked examples that will bring your plots from plain old publishable to down right beautiful. If you have a really specific question, the “ggplot” tag on Stack Overflow is your best friend. Ask and you shall receive (help)! Quaternions are… hard to describe. They are basically 4-part complex numbers that satisfy certain conditions. This allows them to elegently represent space in higher than 3-dimensions. However, they have been despised for much of their history. In fact, William Thomson, first baron Kelvin, note in 1892 “quaternions..though beautifully ingenious, have been an unmixed evil to those who have touched them in any way…”↩ "],
["functions-1.html", "4 Functions 4.1 Basic Example 4.2 Anatomy of an R function 4.3 Base R functions 4.4 Pipes 4.5 More talk about the help files 4.6 Functions from other packages 4.7 ", " 4 Functions Functions allow you to automate boring tasks so that you don’t have to keep doing the same thing over and over again. There are several advantages of this. As stated above, it is faster for you. When something changes (e.g., a reviewer wants you to exclude outliers), you only need to change your code in one place, rather than several. You eliminate the risk of “copy-and-paste” mistakes. This chapter covers the basics of function construction and use. 4.1 Basic Example x &lt;- 1:10 y &lt;- 2:20 z &lt;- 3:34 # Obscure reviewer request x &lt;- x/2 x &lt;- sqrt(x) x &lt;- round(x) y &lt;- y/2 y &lt;- sqrt(y) y &lt;- round(x) z &lt;- z/2 z &lt;- sqrt(z) z &lt;- round(z) 4.2 Anatomy of an R function Making functions speeds up the process and makes it safer. To make a function, we need to use the function() command, assign it to a name, provide potential parameters, then give it code to execute. reviewer_transformation &lt;- function(vals) { vals &lt;- vals/2 vals &lt;- sqrt(vals) vals &lt;- round(vals) vals } # Obscure reviewer request x &lt;- 1:10 x &lt;- x/2 x &lt;- sqrt(x) x &lt;- round(x) x ## [1] 1 1 1 1 2 2 2 2 2 2 other_x &lt;- 1:10 transformed_x &lt;- reviewer_transformation(other_x) x ## [1] 1 1 1 1 2 2 2 2 2 2 Name Parameters/Arguments Defaults Code Return values \\[ r = \\frac{\\text{cov}(x, y)}{\\sigma_x\\sigma_y} \\] # set.seed(314159) x &lt;- 1:10 y &lt;- x*rpois(n = 10, lambda = 3) w &lt;- 1:20 u &lt;- runif(n = 20) cor(x, y) ## [1] 0.8498299 cov(x, y)/(sd(x)*sd(y)) ## [1] 0.8498299 print(&#39;---&#39;) ## [1] &quot;---&quot; correlation &lt;- function(a, b) { cov(a, b)/(sd(a)*sd(b)) } cor(w, u) ## [1] -0.164409 correlation(w, u) ## [1] -0.164409 4.3 Base R functions Basic stat functions Random numbers! x &lt;- rpois(100, 10) y &lt;- 2*x + rnorm(100) df &lt;- data.frame(x, y) library(ggplot2) ggplot(df, aes(x, y)) + geom_point() + geom_hline(yintercept = mean(y), color = &#39;red&#39;) Setting the random seed paste() and paste0() 4.3.1 Scoping What happens inside a function, stays inside a function Discussion of shadow variables 4.3.2 Conditional execution set.seed(314159) x &lt;- 1:10 y &lt;- x*rpois(n = 10, lambda = 3) x[4] &lt;- 1 y[5] &lt;- 2 correlation &lt;- function(a, b) { if(any(is.na(a)) &amp; !any(is.na(b))){ return(&#39;Only one missing data issue.&#39;) } else if(any(is.na(a)) &amp; any(is.na(b))){ return(&#39;You have missing data butthead!&#39;) } else { cov(a, b)/(sd(a)*sd(b)) } } cor(x, y) ## [1] 0.8438 correlation(a = x, b = y) ## [1] 0.8438 if() if()/else() else if() ifelse() 4.3.3 the return() command ————— Part II —————– 4.4 Pipes Sometimes (often) it is useful to execute several functions in a row, using the answer from the last function as the input for the next function. But this can make your code redundant and a little unclear. reviewer_transformation &lt;- function(vals) { vals &lt;- vals/2 vals &lt;- sqrt(vals) vals &lt;- round(vals) vals } reviewer_transformation2 &lt;- function(vals) { round(sqrt(vals/2)) } reviewer_transformation_pipe &lt;- function(vals) { vals %&gt;% magrittr::divide_by(2) %&gt;% sqrt() %&gt;% round() } x &lt;- 1:10 reviewer_transformation(x) ## [1] 1 1 1 1 2 2 2 2 2 2 reviewer_transformation2(x) ## [1] 1 1 1 1 2 2 2 2 2 2 reviewer_transformation_pipe(x) ## [1] 1 1 1 1 2 2 2 2 2 2 library(magrittr) fun1 &lt;- function(x){ x *2 } fun2 &lt;- function(y) { y - 3 } fun2(fun1(x)) ## [1] -1 1 3 5 7 9 11 13 15 17 x %&gt;% fun1() %&gt;% fun2() ## [1] -1 1 3 5 7 9 11 13 15 17 To address this, we use pipes. 4.4.1 Basic usage The %&gt;% operator (pronounced “pipe”) takes whatever is on its left-hand-side (LHS) and applies it to the first parameter of the function listed on the right-hand-side. Install and load the magrittr package to use it. install.packages(&#39;magrittr&#39;) library(magrittr) 4.4.2 Sending the LHS to another parameter But what do I do when I need the LHS output to go to another parameter in the RHS function? I use the . to remind the RHS function I want the LHS output to go to a different place. 4.4.3 Convenient magrittr functions 4.5 More talk about the help files 4.6 Functions from other packages I can import functions from another package by… What if I only want to import once? Namespace considerations 4.7 "],
["dataframes-1.html", "5 Dataframes 5.1 Storing rectangular data 5.2 Accessing data from a dataframe 5.3 Manupilating data 5.4 Using dplyr pipelines 5.5 dplyr pipelines with the magrittr %&gt;%", " 5 Dataframes In this chapter, we will address four issues: How to store rectanglar data How to access the data we have stored How to modify an existing dataset Using dplyr and magrittr pipes to make these tasks much easier (Praise Hadley Wickam!) 5.1 Storing rectangular data Rectangular or “relational” data are the kind with which you are undoubtedly most familiar. In rectangular datasets, rows represent observations (e.g., people, days, soil samples) and columns represent attributes of those observations (e.g., age, temperature, acidity). Because rectangular datasets are so common and so flexible, R has a special framework for storing and manipulating them: the dataframe. There are really only two rules: Columns can have different kinds of data (e.g., strings, numbers), but within a column everything has to be of the same type. All columns have to be of exactly equal length. If I have 10 values (including NA) in my first column, I need exactly 10 in all the other columns. 5.1.1 Making dataframes You can make a dataframe with the data.frame() command, just feed it some data and assign it to a variable. gender_data &lt;- c(&#39;Male&#39;, &#39;Female&#39;, &#39;Female&#39;, &#39;Male&#39;, &#39;Female&#39;) shoe_data &lt;- c(&#39;Nikes&#39;, &#39;Reebok&#39;, &#39;Adididas&#39;, &#39;Manolos&#39;, &#39;Nikes&#39;) age_data &lt;- c(18, NA, 19, 21, 18) df &lt;- data.frame(gender_data, shoe_data, age_data) df ## gender_data shoe_data age_data ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 If I want to give specific names to my columns, I can do that too. df &lt;- data.frame(gender = gender_data, shoe = shoe_data, age = age_data) df ## gender shoe age ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 5.1.2 Strings as factors In chapter 1, we talked about different kinds of data, including numbers, strings, and booleans. There are a few other kinds too, like factors. These are strings that are being used to represent categorical data (which may or may not be ordinal). For historical reasons, R’s data.frame() function defaults to turning any string variable into a factor. Most of the time, this doesn’t matter. However, if you ever need your strings to stay strings, then simply set the stringsAsFactors argument to false when you are making your dataframe. df &lt;- data.frame( gender = gender_data, shoe = shoe_data, age = age_data, stringsAsFactors = FALSE) df ## gender shoe age ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 5.2 Accessing data from a dataframe 5.2.1 Basic framework I can access specific rows and columns using the df[&lt;rows&gt;, &lt;columns&gt;] framework. For example, if I want the 4th row and 3rd column of the dataframe above, I can enter: df[4, 3] ## [1] 21 If I leave an entry before or after my comma (,) empty, then R will give me all the rows or all the columns, respectively. df[4, ] # give me row 4, with all the columns ## gender shoe age ## 4 Male Manolos 21 df[, 3] # give me column 3, with all the rows ## [1] 18 NA 19 21 18 Sometimes, I might want more than one row. In that case, I just enter a vector of values I want. Note, I can even ask for them out of order (and they will be delivered out of order). df[c(3, 1, 2), 3] ## [1] 19 18 NA The same rules apply for requesting multiple columns. I can ask for a vector of columns (in whatever order I want - notice the code below will rearrange them, compared to the first code block above). df[c(3, 1, 2), c(2, 3, 1)] ## shoe age gender ## 3 Adididas 19 Female ## 1 Nikes 18 Male ## 2 Reebok NA Female 5.2.2 Using string column names I can also request columns by their “string” names (e.g., ‘shoe’, ‘age’). df[c(3, 1, 2), c(&#39;shoe&#39;, &#39;age&#39;)] ## shoe age ## 3 Adididas 19 ## 1 Nikes 18 ## 2 Reebok NA 5.2.3 Using the $ operator I can also use the $ operator to request a specific column. df$gender ## [1] &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; 5.2.4 Using booleans Note that I can also ask for rows (or columns) with T/F (boolean) values. You can think of this as R asking, “tell me true or false for which rows you want.” For example, if I wanted to analyze the female members of the dataset only, I would put T values for each of their rows, like so. is_female &lt;- c(F, T, T, F, T) df[is_female, ] ## gender shoe age ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 5 Female Nikes 18 This might look pretty tedious - and it is. However, this same system can be greatly sped up by using other dataframe tricks too, like the $ operator. is_female &lt;- df$gender == &#39;Female&#39; df[is_female, ] ## gender shoe age ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 5 Female Nikes 18 If we wanted to make this even shorter, we could simply write this single-line version below. You can read this in English as “give me my dataframe, but with only the rows where the gender is equal to female”. df[df$gender == &#39;Female&#39;, ] ## gender shoe age ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 5 Female Nikes 18 5.3 Manupilating data Much of what we want to do in R is manipulate data that are net yet in a form where they can be analyzed. We can do that by simply assigning values to the dataframe, using the same access convensions (numbered columns, named columns, or the $ operator) above. Lets make a column that tells us how long the participants have been legally an adult (i.e., how many years since they turned 18). df[, 4] &lt;- df$age - 18 df ## gender shoe age V4 ## 1 Male Nikes 18 0 ## 2 Female Reebok NA NA ## 3 Female Adididas 19 1 ## 4 Male Manolos 21 3 ## 5 Female Nikes 18 0 This worked, but it failed to give us a convenient name for our variable because we didn’t give R any way to name our variables. Let’s try using the named column approach. df[, &#39;years_as_adult&#39;] &lt;- df$age - 18 df ## gender shoe age V4 years_as_adult ## 1 Male Nikes 18 0 0 ## 2 Female Reebok NA NA NA ## 3 Female Adididas 19 1 1 ## 4 Male Manolos 21 3 3 ## 5 Female Nikes 18 0 0 That gave us exactly what we needed, a new named column. But we still have that pesky old column that go misnamed. To delete a dataframe column, assign it the value of NULL. df[, 4] &lt;- NULL df ## gender shoe age years_as_adult ## 1 Male Nikes 18 0 ## 2 Female Reebok NA NA ## 3 Female Adididas 19 1 ## 4 Male Manolos 21 3 ## 5 Female Nikes 18 0 That’s better. Now lets try one other method for manipulating our data, using the $ operator. Let’s make a new column indicating how long it will be until the participants in our dataset are of the legal age to consume alcohol in the United States. df$years_unti_alc &lt;- 21 - df$age 5.4 Using dplyr pipelines Our Lord and Savior, Hadley Wickham has given us the gift of dplyr in 2014. If you’re new to R and trying to understand how important that is, it was a lot like when Promethius gave humanity the gift of fire, only he wasn’t chained to a rock for doing so - that I know of. The general motivation for the dplyr package is that there are only a small number of ways you should be working with rectangular data to achieve 99% of the things you care about. That package makes these very easy to do. The main functions provided by dplyr are: select() - for selecting columns mutate() - for changing calumns filter() - for selecting rows group_by() - for performing tasks within groups summarize() - for aggregating data (e.g., group means, variances) The dplyr position is generally: if you want to do something other than one of these five things, you are probably behaving irresponsibly. Often this is true, the dplyr framework really has captured the general principles of working with rectangular data well. On the rare instance when you reeeeally need something else, you’ll have to code it yourself with the tools from the first section of this chapter or a custom function with the tools from the previous chapter. 5.4.1 How do these functions work? dplyr functions all work by taking at least two inputs: (1) a dataframe and (2) what you want to do to that dataframe. They all return the same thing: another dataframe, with the modifications you requested. 5.4.1.1 select() For example, if I use the select() function and list the columns I want, I will get a new dataframe with just those columns. Notice I don’t need to put quotes in dplyr functions. There are some complicated reasons for this that involve black magic from the Tidyverse, which I’ll tell you about when you’re older. library(dplyr) select(df, shoe) ## shoe ## 1 Nikes ## 2 Reebok ## 3 Adididas ## 4 Manolos ## 5 Nikes I can also just keep asking for more columns, by using more commas. select(df, shoe, age) ## shoe age ## 1 Nikes 18 ## 2 Reebok NA ## 3 Adididas 19 ## 4 Manolos 21 ## 5 Nikes 18 Most often, is a good idea to save my modified dataframe to another dataframe. modified_df &lt;- select(df, shoe, age) modified_df ## shoe age ## 1 Nikes 18 ## 2 Reebok NA ## 3 Adididas 19 ## 4 Manolos 21 ## 5 Nikes 18 5.4.1.2 mutate() To make new columns, I can use the mutate() function and specify what my new columns should be equal to. df &lt;- mutate(df, age_squared = age^2) df ## gender shoe age years_as_adult years_unti_alc age_squared ## 1 Male Nikes 18 0 3 324 ## 2 Female Reebok NA NA NA NA ## 3 Female Adididas 19 1 2 361 ## 4 Male Manolos 21 3 0 441 ## 5 Female Nikes 18 0 3 324 5.4.1.3 filter() To eliminate anyone who doesn’t meet some condition. Use the filter command and give it a condition that results in either TRUE or FALSE. under_19_df &lt;- filter(df, age &lt; 19) under_19_df ## gender shoe age years_as_adult years_unti_alc age_squared ## 1 Male Nikes 18 0 3 324 ## 2 Female Nikes 18 0 3 324 5.4.2 group_by() This function is best used in combination with other dplyr functions, as it doesn’t do much on it’s own. Technically, it creates a “grouped tibble”, which is special kind of dataframe that knows you want to do all your dplyr operations within each group. Notice, however, you can’t see that anything has changed. group_by(df, shoe) ## # A tibble: 5 x 6 ## # Groups: shoe [4] ## gender shoe age years_as_adult years_unti_alc age_squared ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Male Nikes 18 0 3 324 ## 2 Female Reebok NA NA NA NA ## 3 Female Adididas 19 1 2 361 ## 4 Male Manolos 21 3 0 441 ## 5 Female Nikes 18 0 3 324 But if we use group_by() is the input for a mutate() command, we can compute the mean age of each gender (see last column of the newly created dataframe). df &lt;- mutate(group_by(df, gender), mean_age = mean(age, na.rm = T)) 5.4.2.1 summarize() This summarizes some feature of your dataframe by applying an aggregate function to a given column (e.g., mean, max, variance). summarise(df, age_mean = mean(age, na.rm = T)) ## # A tibble: 2 x 2 ## gender age_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 Female 18.5 ## 2 Male 19.5 Most often, it is used in combination with group_by(). summarise(group_by(df, gender), age_mean = mean(age, na.rm = T)) ## # A tibble: 2 x 2 ## gender age_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 Female 18.5 ## 2 Male 19.5 5.5 dplyr pipelines with the magrittr %&gt;% All dplyr functions are designed to be used in combination with the magrittr pipe. This makes using several of them in a row easy to write and easy to read. Imagine we start with the same dataframe at the beginning of the chapter. Let’s use a pipeline to filter out any missing age values, assign new variable, years_as_adult, and explore the mean and standard deviation of that new variable. First, we reset that dataframe df &lt;- data.frame( gender = gender_data, shoe = shoe_data, age = age_data, stringsAsFactors = FALSE) df ## gender shoe age ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 Then we make a pipeline, performing all of the tasks we just described. After each task, we make sure to use a pipe, so that our result gets fed into the next function. df %&gt;% filter(!is.na(age)) %&gt;% mutate(years_as_adult = age - 18) %&gt;% group_by(gender) %&gt;% summarise( mean = mean(years_as_adult), sd = sd(years_as_adult)) ## # A tibble: 2 x 3 ## gender mean sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female 0.5 0.707 ## 2 Male 1.5 2.12 "],
["local-data-import-and-export.html", "6 Local Data Import and Export 6.1 Basic exportation to a .csv file 6.2 Reading in rectangular data 6.3 Importing data from other programs", " 6 Local Data Import and Export In this chapter we will address the following issues: How to write data to a spreadsheet (.csv file) How to read in a simple spreadsheet as a dataframe How to read in SPSS files 6.1 Basic exportation to a .csv file As we discussed in the previous chapter, rectangular data (where rows are observations and columns are attributes of those observations) have a special status in data analysis. They are simple to construct, manipulate, and analyze. For those reasons, a vast majority of the time they will be all you need. R knows this, so it has several functions designed specifically for data in this format (e.g., all the special things you can do with a dataframe). For example, let’s imagine you wanted to export the data we used in the previous chapter (which we can reload here, for convenience). df &lt;- data.frame( gender = c(&#39;Male&#39;, &#39;Female&#39;, &#39;Female&#39;, &#39;Male&#39;, &#39;Female&#39;), shoe = c(&#39;Nikes&#39;, &#39;Reebok&#39;, &#39;Adididas&#39;, &#39;Manolos&#39;, &#39;Nikes&#39;), age = c(18, NA, 19, 21, 18), stringsAsFactors = FALSE) df ## gender shoe age ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 We can write that dataframe to a comma-seperated values (“.csv”) file, using R’s write.csv() function. This function takes two main arguments: the data you want to export and the filename you want your exported data to have (don’t forget to add “.csv” at the end!). write.csv(df, file = &#39;my_shoe_data.csv&#39;) To see what this did, go find the file that R created and try to open it with a spreadsheet program (e.g., Excel). If you don’t know where to look, remember you can use the getwd() command to ask R where it is saving files. getwd() 6.1.1 Other options If you’ve looked at the exported file, you’ve probably noticed there is a new column on the left that wasn’t in our original dataframe. Those are the rownames for your dataframe. Usually they are just numbers, but you can change them to whatever you want. Almost always, they just get in the way. To make sure they don’t get exported along with your other data, you can set rownames = F in your write.csv() call. write.csv(df, file = &#39;my_shoe_data.csv&#39;, row.names = F) Note that this will over-write the existing file! Of course, that is usually what you want, but just make sure you are not overwriting something you wanted to save. 6.2 Reading in rectangular data Most of the time, rectangular data come in the form of a .csv file. This is the kind of file you just created in the last section. It has a simple structure, where all rows occurr on seperate lines of the file and columns within those rows are seperated by commas. To see what they look like “under the hood”, try opening the .csv file from the last section in a text editor, like Notepad or RStudio’s built in text editor. 6.2.1 Traditional importation To read a .csv file into R, we simply use the read.csv() command, storing the result to a dataframe. df &lt;- read.csv(&#39;my_shoe_data.csv&#39;) df ## gender shoe age ## 1 Male Nikes 18 ## 2 Female Reebok NA ## 3 Female Adididas 19 ## 4 Male Manolos 21 ## 5 Female Nikes 18 6.2.2 Importation options to know about Note there are a few important parameters to this function we can alter here, if we want. You can see them using the ?read.csv help file, but I’ll summarize the big ones here. header - should the first line of the incoming file (the “header”) be treated as the variable names? This defaults to TRUE because it is almost always the case, but you should be aware of it, in case your incoming data looks different. sep - This is the symbol R will use to differentiate columns. It is nearly always a “,” but you can change it if there is something special about your data. na.strings - The symbol R will use to denote NA (missing) data. Often, people do silly things like using “-999” to code missing data. After you are done feeling ashamed of them for that very irresponsible decision, you can import their data by setting na.strings = '-999', which will convert all those values to NA during the import. skip - sometimes your data don’t begin on the first line of the incoming file. You can tell R to “skip” those unimportant lines by incrementing the numeric value of this parameter. stringsAsFactors - we talked about this during dataframe creation in the previous chapter. R defaults to bringing all string variables in as categorical. This used to make sense, but in the modern world is kind of a nuisance. Most often, it is best to set to FALSE. 6.2.3 Consider the readr package As the last section might have implied, there are several options you can change to influence how your .csvs are imported. Some of them default to values that don’t really make sense anymore (e.g., stringsAsFactors = TRUE). The readr package attempts to resolve some of this, by offering the same set of importation functions as base R, but providing more sensible defaults. To use this package, install the tidyverse, which contains readr in it. install.packages(&#39;tidyverse&#39;) Then load readr and use the read_csv() function. library(readr) df &lt;- read_csv(&#39;my_shoe_data.csv&#39;) ## Parsed with column specification: ## cols( ## gender = col_character(), ## shoe = col_character(), ## age = col_double() ## ) Notice that read_csv() did not need to be told your strings were not factors, as it’s default behavior is to assume you wanted character variables. Both readr’s read_csv() function and base R’s read.csv() will generally work for your purposes, but read_csv() is generally more reliable, so it is worth making your default. 6.3 Importing data from other programs Sometimes, we want to import data that are more than just simple numbers, letters, and commas. For example, the data might come in SPSS format. To see how this is done, let’s first download some example data. In this case, we’ll be looking at some exam scores formatted as a .sav (SPSS) file. Note, there are many packages that are designed to import non-R files into R. For example, the most popular one in the past was the foreign package, though it has been replaced by more modern packages. My personal favorite is the memisc package, which offers substantial control over how the importation process occurs. When working with large datasets, this can be very important. However, this package would probably be like using a sledge hammer to pound a nail, when working with a small dataset. For our purposes today, we will use the haven package. If you haven’t installed it already, make sure to do so. install.packages(&#39;haven&#39;) Then load the library and use the read_sav() function. library(haven) df &lt;- read_sav(&#39;exam.sav&#39;) Now we can use the head() function to look at the “head” (first six lines) of our newly imported dataset. head(df) ## # A tibble: 6 x 4 ## ID gender exam scores ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 f 1 45 ## 2 1 f 2 33 ## 3 1 f 3 29.5 ## 4 2 f 1 44 ## 5 2 f 2 33 ## 6 2 f 3 27 "]
]
